// =============================================================================// CryptoPulse Exchange Service - Cloud Function// =============================================================================// Handles exchange API integration and trading operationsconst express = require('express');const axios = require('axios');const crypto = require('crypto');const router = express.Router();// Exchange configurationsconst EXCHANGES = {  binance: {    baseUrl: 'https://api.binance.com',    testnetUrl: 'https://testnet.binance.vision',    endpoints: {      price: '/api/v3/ticker/price',      orderbook: '/api/v3/depth',      account: '/api/v3/account',      order: '/api/v3/order'    }  },  wazirx: {    baseUrl: 'https://api.wazirx.com',    endpoints: {      price: '/api/v2/trades',      orderbook: '/api/v2/depth',      account: '/api/v2/account',      order: '/api/v2/orders'    }  },  coindcx: {    baseUrl: 'https://api.coindcx.com',    endpoints: {      price: '/exchange/ticker',      orderbook: '/exchange/v1/markets_details',      account: '/exchange/v1/users/balances',      order: '/exchange/v1/orders/create'    }  }};// Helper function to create signature for authenticated requestsfunction createSignature(queryString, secret) {  return crypto.createHmac('sha256', secret).update(queryString).digest('hex');}// Get current price for a trading pairrouter.post('/price', async (req, res) => {  try {    const { pair, exchange = 'binance' } = req.body;    if (!pair) {      return res.status(400).json({        success: false,        error: 'Trading pair is required'      });    }    const exchangeConfig = EXCHANGES[exchange];    if (!exchangeConfig) {      return res.status(400).json({        success: false,        error: 'Unsupported exchange'      });    }    let priceData;    switch (exchange) {      case 'binance':        priceData = await getBinancePrice(pair, exchangeConfig);        break;      case 'wazirx':        priceData = await getWazirxPrice(pair, exchangeConfig);        break;      case 'coindcx':        priceData = await getCoinDCXPrice(pair, exchangeConfig);        break;      default:        throw new Error('Unsupported exchange');    }    res.json({      success: true,      data: {        pair,        exchange,        price: priceData.price,        timestamp: new Date().toISOString(),        volume: priceData.volume || null,        change24h: priceData.change24h || null      }    });  } catch (error) {    res.status(500).json({      success: false,      error: 'Failed to fetch price data'    });  }});// Get order book for a trading pairrouter.post('/orderbook', async (req, res) => {  try {    const { pair, exchange = 'binance', limit = 100 } = req.body;    if (!pair) {      return res.status(400).json({        success: false,        error: 'Trading pair is required'      });    }    const exchangeConfig = EXCHANGES[exchange];    if (!exchangeConfig) {      return res.status(400).json({        success: false,        error: 'Unsupported exchange'      });    }    const orderbookData = await getOrderBook(pair, exchange, exchangeConfig, limit);    res.json({      success: true,      data: {        pair,        exchange,        bids: orderbookData.bids,        asks: orderbookData.asks,        timestamp: new Date().toISOString()      }    });  } catch (error) {    res.status(500).json({      success: false,      error: 'Failed to fetch order book'    });  }});// Execute traderouter.post('/trade', async (req, res) => {  try {    const {       pair,       side,       amount,       price,       exchange = 'binance',      apiKey,      secretKey,      orderType = 'LIMIT'    } = req.body;    // Validate required fields    if (!pair || !side || !amount || !apiKey || !secretKey) {      return res.status(400).json({        success: false,        error: 'Missing required trading parameters'      });    }    if (!['buy', 'sell'].includes(side)) {      return res.status(400).json({        success: false,        error: 'Invalid side. Must be "buy" or "sell"'      });    }    const exchangeConfig = EXCHANGES[exchange];    if (!exchangeConfig) {      return res.status(400).json({        success: false,        error: 'Unsupported exchange'      });    }    // Execute trade based on exchange    let tradeResult;    switch (exchange) {      case 'binance':        tradeResult = await executeBinanceTrade(pair, side, amount, price, apiKey, secretKey, orderType, exchangeConfig);        break;      case 'wazirx':        tradeResult = await executeWazirxTrade(pair, side, amount, price, apiKey, secretKey, orderType, exchangeConfig);        break;      case 'coindcx':        tradeResult = await executeCoinDCXTrade(pair, side, amount, price, apiKey, secretKey, orderType, exchangeConfig);        break;      default:        throw new Error('Unsupported exchange');    }    res.json({      success: true,      data: {        orderId: tradeResult.orderId,        pair,        side,        amount,        price: tradeResult.price,        status: tradeResult.status,        exchange,        timestamp: new Date().toISOString()      }    });  } catch (error) {    res.status(500).json({      success: false,      error: 'Trade execution failed',      details: error.message    });  }});// Get account balancerouter.post('/balance', async (req, res) => {  try {    const { exchange = 'binance', apiKey, secretKey } = req.body;    if (!apiKey || !secretKey) {      return res.status(400).json({        success: false,        error: 'API credentials are required'      });    }    const exchangeConfig = EXCHANGES[exchange];    if (!exchangeConfig) {      return res.status(400).json({        success: false,        error: 'Unsupported exchange'      });    }    const balanceData = await getAccountBalance(exchange, apiKey, secretKey, exchangeConfig);    res.json({      success: true,      data: {        exchange,        balances: balanceData,        timestamp: new Date().toISOString()      }    });  } catch (error) {    res.status(500).json({      success: false,      error: 'Failed to fetch account balance'    });  }});// Helper functions for different exchangesasync function getBinancePrice(pair, config) {  const response = await axios.get(`${config.baseUrl}${config.endpoints.price}?symbol=${pair}`);  return {    price: parseFloat(response.data.price),    volume: null,    change24h: null  };}async function getWazirxPrice(pair, config) {  const response = await axios.get(`${config.baseUrl}${config.endpoints.price}?market=${pair}`);  const data = response.data[0];  return {    price: parseFloat(data.price),    volume: parseFloat(data.volume),    change24h: null  };}async function getCoinDCXPrice(pair, config) {  const response = await axios.get(`${config.baseUrl}${config.endpoints.price}`);  const data = response.data.find(ticker => ticker.market === pair);  return {    price: parseFloat(data.last_price),    volume: parseFloat(data.volume),    change24h: parseFloat(data.change_24h)  };}async function getOrderBook(pair, exchange, config, limit) {  const response = await axios.get(`${config.baseUrl}${config.endpoints.orderbook}?symbol=${pair}&limit=${limit}`);  return {    bids: response.data.bids,    asks: response.data.asks  };}async function executeBinanceTrade(pair, side, amount, price, apiKey, secretKey, orderType, config) {  const timestamp = Date.now();  const queryString = `symbol=${pair}&side=${side.toUpperCase()}&type=${orderType}&quantity=${amount}&price=${price}&timeInForce=GTC&timestamp=${timestamp}`;  const signature = createSignature(queryString, secretKey);  const response = await axios.post(`${config.baseUrl}${config.endpoints.order}?${queryString}&signature=${signature}`, {}, {    headers: {      'X-MBX-APIKEY': apiKey    }  });  return {    orderId: response.data.orderId,    price: parseFloat(response.data.price),    status: response.data.status  };}async function executeWazirxTrade(pair, side, amount, price, apiKey, secretKey, orderType, config) {  // WazirX specific implementation  const response = await axios.post(`${config.baseUrl}${config.endpoints.order}`, {    market: pair,    side: side,    quantity: amount,    price: price,    type: orderType  }, {    headers: {      'X-API-KEY': apiKey,      'X-API-SECRET': secretKey    }  });  return {    orderId: response.data.id,    price: parseFloat(response.data.price),    status: response.data.status  };}async function executeCoinDCXTrade(pair, side, amount, price, apiKey, secretKey, orderType, config) {  // CoinDCX specific implementation  const response = await axios.post(`${config.baseUrl}${config.endpoints.order}`, {    side: side,    order_type: orderType,    market: pair,    price_per_unit: price,    total_quantity: amount  }, {    headers: {      'X-AUTH-APIKEY': apiKey,      'X-AUTH-SIGNATURE': secretKey    }  });  return {    orderId: response.data.id,    price: parseFloat(response.data.price_per_unit),    status: response.data.status  };}async function getAccountBalance(exchange, apiKey, secretKey, config) {  // Implementation for getting account balance  // This would vary by exchange  return [    {      asset: 'BTC',      free: '0.5',      locked: '0.1',      total: '0.6'    },    {      asset: 'ETH',      free: '2.0',      locked: '0.5',      total: '2.5'    }  ];}module.exports = router;