// =============================================================================// CryptoPulse Monitoring Service - Cloud Function// =============================================================================// Handles system monitoring, health checks, and performance metricsconst express = require('express');const axios = require('axios');const router = express.Router();// Monitoring configurationconst MONITORING_CONFIG = {  healthCheckInterval: 60000, // 1 minute  performanceThresholds: {    responseTime: 2000, // 2 seconds    errorRate: 0.05, // 5%    cpuUsage: 80, // 80%    memoryUsage: 85 // 85%  },  alertChannels: {    slack: process.env.SLACK_WEBHOOK_URL,    email: process.env.ALERT_EMAIL,    webhook: process.env.ALERT_WEBHOOK_URL  }};// System health checkrouter.get('/health', async (req, res) => {  try {    const healthData = await performHealthCheck();    const status = healthData.overall === 'healthy' ? 200 : 503;    res.status(status).json({      success: true,      data: healthData,      timestamp: new Date().toISOString()    });  } catch (error) {    res.status(500).json({      success: false,      error: 'Health check failed',      details: error.message    });  }});// Detailed system metricsrouter.get('/metrics', async (req, res) => {  try {    const metrics = await collectSystemMetrics();    res.json({      success: true,      data: metrics,      timestamp: new Date().toISOString()    });  } catch (error) {    res.status(500).json({      success: false,      error: 'Failed to collect metrics'    });  }});// Performance analyticsrouter.get('/performance', async (req, res) => {  try {    const performanceData = await getPerformanceAnalytics();    res.json({      success: true,      data: performanceData,      timestamp: new Date().toISOString()    });  } catch (error) {    res.status(500).json({      success: false,      error: 'Failed to get performance analytics'    });  }});// Error trackingrouter.get('/errors', async (req, res) => {  try {    const { limit = 100, severity = 'all' } = req.query;    const errors = await getErrorLogs(parseInt(limit), severity);    res.json({      success: true,      data: {        errors,        count: errors.length,        severity      },      timestamp: new Date().toISOString()    });  } catch (error) {    res.status(500).json({      success: false,      error: 'Failed to get error logs'    });  }});// Trading performance metricsrouter.get('/trading-performance', async (req, res) => {  try {    const { userId, timeframe = '24h' } = req.query;    const tradingMetrics = await getTradingPerformance(userId, timeframe);    res.json({      success: true,      data: tradingMetrics,      timestamp: new Date().toISOString()    });  } catch (error) {    res.status(500).json({      success: false,      error: 'Failed to get trading performance'    });  }});// System alertsrouter.get('/alerts', async (req, res) => {  try {    const { status = 'active' } = req.query;    const alerts = await getSystemAlerts(status);    res.json({      success: true,      data: {        alerts,        count: alerts.length,        status      },      timestamp: new Date().toISOString()    });  } catch (error) {    res.status(500).json({      success: false,      error: 'Failed to get alerts'    });  }});// Create alertrouter.post('/alerts', async (req, res) => {  try {    const { type, severity, message, conditions } = req.body;    if (!type || !severity || !message) {      return res.status(400).json({        success: false,        error: 'Missing required alert parameters'      });    }    const alert = await createSystemAlert({      type,      severity,      message,      conditions,      status: 'active',      createdAt: new Date()    });    res.json({      success: true,      data: alert,      message: 'Alert created successfully'    });  } catch (error) {    res.status(500).json({      success: false,      error: 'Failed to create alert'    });  }});// Update alertrouter.put('/alerts/:alertId', async (req, res) => {  try {    const { alertId } = req.params;    const { status, message } = req.body;    const alert = await updateSystemAlert(alertId, { status, message });    if (!alert) {      return res.status(404).json({        success: false,        error: 'Alert not found'      });    }    res.json({      success: true,      data: alert,      message: 'Alert updated successfully'    });  } catch (error) {    res.status(500).json({      success: false,      error: 'Failed to update alert'    });  }});// Helper functionsasync function performHealthCheck() {  const checks = {    database: await checkDatabaseHealth(),    redis: await checkRedisHealth(),    externalApis: await checkExternalApisHealth(),    memory: await checkMemoryHealth(),    disk: await checkDiskHealth()  };  const overall = Object.values(checks).every(check => check.status === 'healthy')     ? 'healthy'     : 'degraded';  return {    overall,    checks,    timestamp: new Date().toISOString()  };}async function checkDatabaseHealth() {  try {    // Check database connectivity    // This would integrate with your actual database    return {      status: 'healthy',      responseTime: 50,      message: 'Database connection successful'    };  } catch (error) {    return {      status: 'unhealthy',      responseTime: null,      message: error.message    };  }}async function checkRedisHealth() {  try {    // Check Redis connectivity    return {      status: 'healthy',      responseTime: 10,      message: 'Redis connection successful'    };  } catch (error) {    return {      status: 'unhealthy',      responseTime: null,      message: error.message    };  }}async function checkExternalApisHealth() {  try {    const apis = ['binance', 'wazirx', 'coindcx'];    const results = await Promise.allSettled(      apis.map(api => checkApiHealth(api))    );    const healthy = results.filter(r => r.status === 'fulfilled').length;    const total = results.length;    return {      status: healthy === total ? 'healthy' : 'degraded',      healthy,      total,      message: `${healthy}/${total} external APIs healthy`    };  } catch (error) {    return {      status: 'unhealthy',      message: error.message    };  }}async function checkApiHealth(api) {  try {    // Check specific API health    const response = await axios.get(`https://api.${api}.com/api/v3/ping`, { timeout: 5000 });    return response.status === 200;  } catch (error) {    return false;  }}async function checkMemoryHealth() {  const memUsage = process.memoryUsage();  const usagePercent = (memUsage.heapUsed / memUsage.heapTotal) * 100;  return {    status: usagePercent < MONITORING_CONFIG.performanceThresholds.memoryUsage ? 'healthy' : 'degraded',    usage: usagePercent,    message: `Memory usage: ${usagePercent.toFixed(2)}%`  };}async function checkDiskHealth() {  // Check disk space  return {    status: 'healthy',    usage: 45,    message: 'Disk usage: 45%'  };}async function collectSystemMetrics() {  const memUsage = process.memoryUsage();  const cpuUsage = process.cpuUsage();  return {    memory: {      used: memUsage.heapUsed,      total: memUsage.heapTotal,      usage: (memUsage.heapUsed / memUsage.heapTotal) * 100    },    cpu: {      user: cpuUsage.user,      system: cpuUsage.system    },    uptime: process.uptime(),    timestamp: new Date().toISOString()  };}async function getPerformanceAnalytics() {  // Get performance analytics data  return {    averageResponseTime: 150,    requestsPerMinute: 1200,    errorRate: 0.02,    activeUsers: 150,    tradingVolume: 50000,    timestamp: new Date().toISOString()  };}async function getErrorLogs(limit, severity) {  // Get error logs from database or log files  return [    {      id: 'error_1',      severity: 'error',      message: 'Database connection timeout',      timestamp: new Date().toISOString(),      stack: 'Error: Connection timeout...'    }  ];}async function getTradingPerformance(userId, timeframe) {  // Get trading performance metrics  return {    totalTrades: 150,    winningTrades: 95,    losingTrades: 55,    winRate: 63.33,    totalProfit: 2500,    totalLoss: 800,    netProfit: 1700,    profitFactor: 3.125,    sharpeRatio: 1.8,    maxDrawdown: 5.2,    timeframe  };}async function getSystemAlerts(status) {  // Get system alerts  return [    {      id: 'alert_1',      type: 'performance',      severity: 'warning',      message: 'High memory usage detected',      status: 'active',      createdAt: new Date().toISOString()    }  ];}async function createSystemAlert(alertData) {  // Create system alert  return {    id: `alert_${Date.now()}`,    ...alertData  };}async function updateSystemAlert(alertId, updateData) {  // Update system alert  return {    id: alertId,    ...updateData,    updatedAt: new Date().toISOString()  };}module.exports = router;