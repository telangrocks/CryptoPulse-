/** * @fileoverview Comprehensive error handling utilities for Redux store * @version 1.0.0 * @author CryptoPulse Team */import { ErrorState, ApiError, createApiError, createNetworkError, createAuthError } from '../types';// ============================================================================// ERROR TYPES AND CONSTANTS// ============================================================================/** * Error codes for different types of errors */export const ERROR_CODES = {  // Network errors  NETWORK_ERROR: 'NETWORK_ERROR',  TIMEOUT_ERROR: 'TIMEOUT_ERROR',  CONNECTION_ERROR: 'CONNECTION_ERROR',  // Authentication errors  AUTH_ERROR: 'AUTH_ERROR',  TOKEN_EXPIRED: 'TOKEN_EXPIRED',  INVALID_CREDENTIALS: 'INVALID_CREDENTIALS',  SESSION_EXPIRED: 'SESSION_EXPIRED',  // Validation errors  VALIDATION_ERROR: 'VALIDATION_ERROR',  INVALID_INPUT: 'INVALID_INPUT',  MISSING_REQUIRED_FIELD: 'MISSING_REQUIRED_FIELD',  // Permission errors  PERMISSION_ERROR: 'PERMISSION_ERROR',  INSUFFICIENT_PERMISSIONS: 'INSUFFICIENT_PERMISSIONS',  ACCESS_DENIED: 'ACCESS_DENIED',  // Trading errors  TRADING_ERROR: 'TRADING_ERROR',  INSUFFICIENT_BALANCE: 'INSUFFICIENT_BALANCE',  INVALID_ORDER: 'INVALID_ORDER',  MARKET_CLOSED: 'MARKET_CLOSED',  // Bot errors  BOT_ERROR: 'BOT_ERROR',  BOT_CONFIG_ERROR: 'BOT_CONFIG_ERROR',  BOT_EXECUTION_ERROR: 'BOT_EXECUTION_ERROR',  // System errors  SYSTEM_ERROR: 'SYSTEM_ERROR',  UNKNOWN_ERROR: 'UNKNOWN_ERROR',  INTERNAL_ERROR: 'INTERNAL_ERROR'} as const;/** * Retry configuration for different error types */export const RETRY_CONFIG = {  [ERROR_CODES.NETWORK_ERROR]: { maxRetries: 3, retryDelay: 1000, backoffMultiplier: 2 },  [ERROR_CODES.TIMEOUT_ERROR]: { maxRetries: 2, retryDelay: 2000, backoffMultiplier: 1.5 },  [ERROR_CODES.CONNECTION_ERROR]: { maxRetries: 5, retryDelay: 500, backoffMultiplier: 2 },  [ERROR_CODES.TOKEN_EXPIRED]: { maxRetries: 1, retryDelay: 0, backoffMultiplier: 1 },  [ERROR_CODES.AUTH_ERROR]: { maxRetries: 0, retryDelay: 0, backoffMultiplier: 1 },  [ERROR_CODES.VALIDATION_ERROR]: { maxRetries: 0, retryDelay: 0, backoffMultiplier: 1 },  [ERROR_CODES.PERMISSION_ERROR]: { maxRetries: 0, retryDelay: 0, backoffMultiplier: 1 },  [ERROR_CODES.TRADING_ERROR]: { maxRetries: 1, retryDelay: 1000, backoffMultiplier: 1 },  [ERROR_CODES.BOT_ERROR]: { maxRetries: 2, retryDelay: 2000, backoffMultiplier: 1.5 },  [ERROR_CODES.SYSTEM_ERROR]: { maxRetries: 1, retryDelay: 5000, backoffMultiplier: 1 }} as const;// ============================================================================// ERROR CREATION UTILITIES// ============================================================================/** * Creates a standardized error state * @param code - Error code * @param message - Error message * @param details - Additional error details * @param context - Error context * @returns Error state object */export const createErrorState = (  code: string,  message: string,  details?: Record<string, any>,  context?: string): ErrorState => {  const retryConfig = RETRY_CONFIG[code as keyof typeof RETRY_CONFIG] || RETRY_CONFIG[ERROR_CODES.UNKNOWN_ERROR];  return {    code,    message,    details,    recoverable: retryConfig.maxRetries > 0,    retryCount: 0,    maxRetries: retryConfig.maxRetries,    timestamp: Date.now(),    context  };};/** * Creates an error state from an API error * @param apiError - API error object * @param context - Error context * @returns Error state object */export const createErrorStateFromApiError = (apiError: ApiError, context?: string): ErrorState => {  return createErrorState(    apiError.code,    apiError.message,    apiError.details,    context  );};/** * Creates an error state from a JavaScript Error * @param error - JavaScript Error object * @param context - Error context * @returns Error state object */export const createErrorStateFromError = (error: Error, context?: string): ErrorState => {  let code = ERROR_CODES.UNKNOWN_ERROR;  let message = error.message;  // Determine error code based on error message or type  if (error.message.includes('Network Error') || error.message.includes('fetch')) {    code = ERROR_CODES.NETWORK_ERROR;  } else if (error.message.includes('timeout')) {    code = ERROR_CODES.TIMEOUT_ERROR;  } else if (error.message.includes('401') || error.message.includes('Unauthorized')) {    code = ERROR_CODES.AUTH_ERROR;  } else if (error.message.includes('403') || error.message.includes('Forbidden')) {    code = ERROR_CODES.PERMISSION_ERROR;  } else if (error.message.includes('validation') || error.message.includes('invalid')) {    code = ERROR_CODES.VALIDATION_ERROR;  }  return createErrorState(code, message, { originalError: error.name }, context);};// ============================================================================// ERROR RECOVERY UTILITIES// ============================================================================/** * Determines if an error can be retried * @param errorState - Error state object * @returns True if error can be retried */export const canRetry = (errorState: ErrorState): boolean => {  return errorState.recoverable &&          errorState.retryCount < errorState.maxRetries &&         !isPermanentError(errorState);};/** * Determines if an error is permanent (should not be retried) * @param errorState - Error state object * @returns True if error is permanent */export const isPermanentError = (errorState: ErrorState): boolean => {  const permanentCodes = [    ERROR_CODES.AUTH_ERROR,    ERROR_CODES.INVALID_CREDENTIALS,    ERROR_CODES.PERMISSION_ERROR,    ERROR_CODES.INSUFFICIENT_PERMISSIONS,    ERROR_CODES.VALIDATION_ERROR,    ERROR_CODES.INVALID_INPUT  ];  return permanentCodes.includes(errorState.code as any);};/** * Calculates the next retry delay * @param errorState - Error state object * @returns Next retry delay in milliseconds */export const calculateRetryDelay = (errorState: ErrorState): number => {  const retryConfig = RETRY_CONFIG[errorState.code as keyof typeof RETRY_CONFIG] || RETRY_CONFIG[ERROR_CODES.UNKNOWN_ERROR];  if (errorState.retryCount === 0) {    return retryConfig.retryDelay;  }  return Math.min(    retryConfig.retryDelay * Math.pow(retryConfig.backoffMultiplier, errorState.retryCount),    30000 // Max 30 seconds  );};/** * Creates a new error state with incremented retry count * @param errorState - Current error state * @returns New error state with incremented retry count */export const incrementRetryCount = (errorState: ErrorState): ErrorState => {  return {    ...errorState,    retryCount: errorState.retryCount + 1,    lastRetry: Date.now()  };};// ============================================================================// ERROR LOGGING UTILITIES// ============================================================================/** * Logs an error with appropriate level and context * @param errorState - Error state to log * @param additionalContext - Additional context information */export const logError = (errorState: ErrorState, additionalContext?: Record<string, any>): void => {  const logData = {    code: errorState.code,    message: errorState.message,    details: errorState.details,    context: errorState.context,    retryCount: errorState.retryCount,    timestamp: errorState.timestamp,    ...additionalContext  };  // Determine log level based on error severity  if (isCriticalError(errorState)) {    // In production, send to error tracking service    if (process.env.NODE_ENV === 'production') {      // sendToErrorTrackingService(logData);    }  } else if (isWarningError(errorState)) {  } else {  }};/** * Determines if an error is critical * @param errorState - Error state object * @returns True if error is critical */export const isCriticalError = (errorState: ErrorState): boolean => {  const criticalCodes = [    ERROR_CODES.SYSTEM_ERROR,    ERROR_CODES.INTERNAL_ERROR,    ERROR_CODES.AUTH_ERROR,    ERROR_CODES.PERMISSION_ERROR  ];  return criticalCodes.includes(errorState.code as any);};/** * Determines if an error is a warning * @param errorState - Error state object * @returns True if error is a warning */export const isWarningError = (errorState: ErrorState): boolean => {  const warningCodes = [    ERROR_CODES.NETWORK_ERROR,    ERROR_CODES.TIMEOUT_ERROR,    ERROR_CODES.TRADING_ERROR,    ERROR_CODES.BOT_ERROR  ];  return warningCodes.includes(errorState.code as any);};// ============================================================================// ERROR RECOVERY STRATEGIES// ============================================================================/** * Error recovery strategies for different error types */export const ERROR_RECOVERY_STRATEGIES = {  [ERROR_CODES.NETWORK_ERROR]: 'retry_with_backoff',  [ERROR_CODES.TIMEOUT_ERROR]: 'retry_with_backoff',  [ERROR_CODES.CONNECTION_ERROR]: 'retry_with_exponential_backoff',  [ERROR_CODES.TOKEN_EXPIRED]: 'refresh_token',  [ERROR_CODES.AUTH_ERROR]: 'redirect_to_login',  [ERROR_CODES.PERMISSION_ERROR]: 'show_permission_denied',  [ERROR_CODES.VALIDATION_ERROR]: 'show_validation_errors',  [ERROR_CODES.TRADING_ERROR]: 'show_trading_error',  [ERROR_CODES.BOT_ERROR]: 'pause_bot_and_notify',  [ERROR_CODES.SYSTEM_ERROR]: 'show_system_error'} as const;/** * Gets the recovery strategy for an error * @param errorState - Error state object * @returns Recovery strategy */export const getRecoveryStrategy = (errorState: ErrorState): string => {  return ERROR_RECOVERY_STRATEGIES[errorState.code as keyof typeof ERROR_RECOVERY_STRATEGIES] || 'show_generic_error';};// ============================================================================// ERROR BOUNDARY UTILITIES// ============================================================================/** * Creates an error boundary state * @param error - Error object * @param errorInfo - Error info from React * @returns Error boundary state */export const createErrorBoundaryState = (error: Error, errorInfo: any) => {  return {    hasError: true,    error: createErrorStateFromError(error, 'ErrorBoundary'),    errorInfo,    timestamp: Date.now()  };};/** * Resets an error boundary state * @returns Reset error boundary state */export const resetErrorBoundaryState = () => {  return {    hasError: false,    error: null,    errorInfo: null,    timestamp: null  };};// ============================================================================// ERROR NOTIFICATION UTILITIES// ============================================================================/** * Creates a user-friendly error message * @param errorState - Error state object * @returns User-friendly error message */export const createUserFriendlyMessage = (errorState: ErrorState): string => {  const messages: Record<string, string> = {    [ERROR_CODES.NETWORK_ERROR]: 'Network connection failed. Please check your internet connection and try again.',    [ERROR_CODES.TIMEOUT_ERROR]: 'Request timed out. Please try again.',    [ERROR_CODES.CONNECTION_ERROR]: 'Unable to connect to the server. Please try again later.',    [ERROR_CODES.AUTH_ERROR]: 'Authentication failed. Please log in again.',    [ERROR_CODES.TOKEN_EXPIRED]: 'Your session has expired. Please log in again.',    [ERROR_CODES.INVALID_CREDENTIALS]: 'Invalid username or password. Please try again.',    [ERROR_CODES.SESSION_EXPIRED]: 'Your session has expired. Please log in again.',    [ERROR_CODES.PERMISSION_ERROR]: 'You do not have permission to perform this action.',    [ERROR_CODES.INSUFFICIENT_PERMISSIONS]: 'Insufficient permissions for this operation.',    [ERROR_CODES.VALIDATION_ERROR]: 'Please check your input and try again.',    [ERROR_CODES.INVALID_INPUT]: 'Invalid input provided. Please check your data.',    [ERROR_CODES.TRADING_ERROR]: 'Trading operation failed. Please try again.',    [ERROR_CODES.INSUFFICIENT_BALANCE]: 'Insufficient balance for this trade.',    [ERROR_CODES.INVALID_ORDER]: 'Invalid order parameters. Please check your order.',    [ERROR_CODES.MARKET_CLOSED]: 'Market is currently closed. Please try again during trading hours.',    [ERROR_CODES.BOT_ERROR]: 'Bot operation failed. Please check your bot configuration.',    [ERROR_CODES.SYSTEM_ERROR]: 'A system error occurred. Please try again later.',    [ERROR_CODES.UNKNOWN_ERROR]: 'An unexpected error occurred. Please try again.'  };  return messages[errorState.code] || errorState.message || 'An unexpected error occurred.';};/** * Determines if an error should show a notification * @param errorState - Error state object * @returns True if error should show notification */export const shouldShowNotification = (errorState: ErrorState): boolean => {  const silentCodes = [    ERROR_CODES.TOKEN_EXPIRED,    ERROR_CODES.SESSION_EXPIRED  ];  return !silentCodes.includes(errorState.code as any);};// ============================================================================// ERROR CLEARING UTILITIES// ============================================================================/** * Clears an error state * @returns Cleared error state */export const clearError = (): ErrorState | null => {  return null;};/** * Clears errors by context * @param context - Error context to clear * @param currentErrors - Current error states * @returns Filtered error states */export const clearErrorsByContext = (context: string, currentErrors: ErrorState[]): ErrorState[] => {  return currentErrors.filter(error => error.context !== context);};/** * Clears old errors (older than specified time) * @param currentErrors - Current error states * @param maxAge - Maximum age in milliseconds * @returns Filtered error states */export const clearOldErrors = (currentErrors: ErrorState[], maxAge: number = 300000): ErrorState[] => {  const cutoffTime = Date.now() - maxAge;  return currentErrors.filter(error => error.timestamp > cutoffTime);};