/** * @fileoverview Production-ready Redux store configuration with enhanced security and performance * @version 1.0.0 * @author CryptoPulse Team */import { configureStore, combineReducers, Middleware, isRejectedWithValue } from '@reduxjs/toolkit';import { persistStore, persistReducer, PersistConfig } from 'redux-persist';import storage from 'redux-persist/lib/storage';import { createTransform } from 'redux-persist';import { performanceMonitor } from './utils/performance';import { createErrorStateFromApiError, logError, isCriticalError } from './utils/errorHandling';import { sanitizeObject } from './utils/validation';// Import slicesimport authSlice from './slices/authSlice';import tradingSlice from './slices/tradingSlice';import uiSlice from './slices/uiSlice';import marketDataSlice from './slices/marketDataSlice';import botSlice from './slices/botSlice';import notificationSlice from './slices/notificationSlice';// Import typesimport { RootState, ApiError } from './types';import { EncryptionService } from '../lib/encryption';// ============================================================================// SECURE STORAGE CONFIGURATION// ============================================================================/** * Secure storage implementation with encryption */const secureStorage = {  getItem: async (key: string): Promise<string | null> => {    try {      const item = localStorage.getItem(key);      if (!item) return null;      // In production, decrypt the data      if (process.env.NODE_ENV === 'production') {        if (EncryptionService.isEncrypted(item)) {          return EncryptionService.decrypt(item);        }        return item;      }      return item;    } catch (error) {      return null;    }  },  setItem: async (key: string, value: string): Promise<void> => {    try {      // In production, encrypt the data      if (process.env.NODE_ENV === 'production') {        const encryptedValue = EncryptionService.encrypt(value);        localStorage.setItem(key, encryptedValue);      } else {        localStorage.setItem(key, value);      }    } catch (error) {    }  },  removeItem: async (key: string): Promise<void> => {    try {      localStorage.removeItem(key);    } catch (error) {    }  }};// ============================================================================// DATA TRANSFORMS// ============================================================================/** * Transform to sanitize data before persisting */const sanitizeTransform = createTransform(  (inboundState: any) => {    return sanitizeObject(inboundState);  },  (outboundState: any) => {    return outboundState;  },  { whitelist: ['ui', 'bot'] });/** * Transform to encrypt sensitive data */const encryptTransform = createTransform(  (inboundState: any) => {    if (process.env.NODE_ENV === 'production') {      // Encrypt sensitive data      const sensitiveKeys = ['apiKeys', 'secrets', 'tokens'];      const encryptedState = { ...inboundState };      sensitiveKeys.forEach(key => {        if (encryptedState[key]) {          try {            encryptedState[key] = EncryptionService.encrypt(JSON.stringify(encryptedState[key]));          } catch (error) {          }        }      });      return encryptedState;    }    return inboundState;  },  (outboundState: any) => {    if (process.env.NODE_ENV === 'production') {      // Decrypt sensitive data      const sensitiveKeys = ['apiKeys', 'secrets', 'tokens'];      const decryptedState = { ...outboundState };      sensitiveKeys.forEach(key => {        if (decryptedState[key] && typeof decryptedState[key] === 'string') {          try {            decryptedState[key] = JSON.parse(EncryptionService.decrypt(decryptedState[key]));          } catch (error) {            // If decryption fails, keep original value          }        }      });      return decryptedState;    }    return outboundState;  },  { whitelist: ['ui', 'bot'] });// ============================================================================// PERSIST CONFIGURATION// ============================================================================/** * Secure persist configuration * Note: Auth data is NOT persisted for security reasons */const persistConfig: PersistConfig<RootState> = {  key: 'cryptopulse-store',  storage: secureStorage,  whitelist: ['ui', 'bot'], // Only persist UI and bot settings, NOT auth data  transforms: [sanitizeTransform, encryptTransform],  version: 1,  migrate: (state: any) => {    // Handle state migration if needed    return state;  }};// ============================================================================// ROOT REDUCER// ============================================================================const rootReducer = combineReducers({  auth: authSlice,  trading: tradingSlice,  ui: uiSlice,  marketData: marketDataSlice,  bot: botSlice,  notification: notificationSlice,});const persistedReducer = persistReducer(persistConfig, rootReducer);// ============================================================================// MIDDLEWARE CONFIGURATION// ============================================================================/** * Error handling middleware */const errorHandlingMiddleware: Middleware = (store) => (next) => (action) => {  const result = next(action);  // Check if action was rejected  if (isRejectedWithValue(action)) {    const error = action.payload as ApiError;    const errorState = createErrorStateFromApiError(error, action.type);    // Log error    logError(errorState, {      action: action.type,      timestamp: Date.now(),      state: store.getState()    });    // Handle critical errors    if (isCriticalError(errorState)) {      // In production, send to error tracking service      if (process.env.NODE_ENV === 'production') {        // sendToErrorTrackingService(errorState);      }    }  }  return result;};/** * Performance monitoring middleware */const performanceMiddleware: Middleware = (store) => (next) => (action) => {  const start = performance.now();  const result = next(action);  const end = performance.now();  // Record performance metrics  performanceMonitor.recordMetric('action_dispatch_time', end - start);  performanceMonitor.recordMetric(`action_${action.type}_time`, end - start);  return result;};/** * Security audit middleware */const securityAuditMiddleware: Middleware = (store) => (next) => (action) => {  // Audit action for security issues  if (action.type.includes('auth') && action.payload) {    // Sanitize auth-related payloads    if (action.payload.password) {      // Remove password from logs      const sanitizedAction = {        ...action,        payload: {          ...action.payload,          password: '[REDACTED]'        }      };    }  }  return next(action);};/** * Development logging middleware */const developmentLoggingMiddleware: Middleware = (store) => (next) => (action) => {  if (process.env.NODE_ENV === 'development') {    console.group(`Action: ${action.type}`);    console.log('Previous State:', store.getState());    const result = next(action);    console.log('Next State:', store.getState());    console.groupEnd();    return result;  }  return next(action);};// ============================================================================// STORE CONFIGURATION// ============================================================================export const store = configureStore({  reducer: persistedReducer,  middleware: (getDefaultMiddleware) =>    getDefaultMiddleware({      serializableCheck: {        ignoredActions: [          'persist/PERSIST',          'persist/REHYDRATE',          'persist/REGISTER',          'persist/FLUSH',          'persist/PAUSE',          'persist/PURGE'        ],        ignoredActionsPaths: ['meta.arg', 'payload.timestamp'],        ignoredPaths: ['_persist']      },      immutableCheck: {        ignoredPaths: ['_persist']      },      thunk: {        extraArgument: {          // Add any extra arguments for thunks here        }      }    })    .concat(errorHandlingMiddleware)    .concat(performanceMiddleware)    .concat(securityAuditMiddleware)    .concat(developmentLoggingMiddleware),  devTools: process.env.NODE_ENV !== 'production' && {    name: 'CryptoPulse Store',    trace: true,    traceLimit: 25,    actionSanitizer: (action) => {      // Sanitize sensitive data in dev tools      if (action.type.includes('auth') && action.payload?.password) {        return {          ...action,          payload: {            ...action.payload,            password: '[REDACTED]'          }        };      }      return action;    },    stateSanitizer: (state) => {      // Sanitize sensitive state in dev tools      if (state.auth?.user?.password) {        return {          ...state,          auth: {            ...state.auth,            user: {              ...state.auth.user,              password: '[REDACTED]'            }          }        };      }      return state;    }  },  enhancers: (getDefaultEnhancers) =>    getDefaultEnhancers({      // Add any enhancers here    })});// ============================================================================// PERSISTOR CONFIGURATION// ============================================================================export const persistor = persistStore(store, {  // Persistor options}, () => {  // Rehydration callback});// ============================================================================// TYPE EXPORTS// ============================================================================export type RootState = ReturnType<typeof store.getState>;export type AppDispatch = typeof store.dispatch;// ============================================================================// STORE UTILITIES// ============================================================================/** * Get current store state * @returns Current store state */export const getCurrentState = (): RootState => store.getState();/** * Dispatch an action to the store * @param action - Action to dispatch * @returns Dispatched action */export const dispatchAction = (action: any) => store.dispatch(action);/** * Subscribe to store changes * @param listener - Listener function * @returns Unsubscribe function */export const subscribeToStore = (listener: () => void) => {  return store.subscribe(listener);};/** * Reset store to initial state * @returns Action to reset store */export const resetStore = () => {  // Clear persisted data  persistor.purge();  // Reset store state  store.dispatch({ type: 'RESET_STORE' });};// ============================================================================// DEVELOPMENT UTILITIES// ============================================================================if (process.env.NODE_ENV === 'development') {  // Expose store to window for debugging  (window as any).__CRYPTOPULSE_STORE__ = store;  (window as any).__CRYPTOPULSE_PERSISTOR__ = persistor;  // Add performance monitoring  (window as any).__CRYPTOPULSE_PERFORMANCE__ = performanceMonitor;}// ============================================================================// EXPORTS// ============================================================================// Typed hooksexport {   useAppDispatch,   useAppSelector,  useMemoizedSelector,  useCustomSelector,  useMonitoredSelector,  useAppStore,  useMultipleSelectors,  useSafeSelector,  useConditionalSelector,  useTrackedSelector,  useSafeStoreAccess,  useDebugSelector,  useSelectorChange,  useDebouncedSelector} from './hooks';// Selectorsexport * from './utils/performance';// Utilitiesexport * from './utils/validation';export * from './utils/errorHandling';