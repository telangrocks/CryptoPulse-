import { TrendingUp, BarChart3, Activity, Volume2, Loader2, AlertTriangle } from 'lucide-react';
import React, { useState, useMemo, useCallback, memo, lazy, Suspense } from 'react';
import {  LineChart,  Line,  AreaChart,  Area,  XAxis,  YAxis,  CartesianGrid,  Tooltip,  ResponsiveContainer,  BarChart,  Bar,  ComposedChart,} from 'recharts';

import { errorMonitoring } from '../lib/errorMonitoring';
import { usePerformanceOptimization, createMemoizedCallback, createMemoizedValue } from '../lib/performanceOptimization';

import { Badge } from './ui/badge';
import { Button } from './ui/button';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';import { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs';// Lazy load heavy chart componentsconst CandlestickChart = lazy(() => import('./CandlestickChart'));const VolumeChart = lazy(() => import('./VolumeChart'));interface ChartData {  timestamp: number;  open: number;  high: number;  low: number;  close: number;  volume: number;  sma?: number;  ema?: number;  rsi?: number;  macd?: number;  bb_upper?: number;  bb_lower?: number;}interface AdvancedChartsProps {  data: ChartData[];  symbol: string;  timeframe: string;  onTimeframeChange: (timeframe: string) => void;  className?: string;}// Memoized chart componentsconst MemoizedLineChart = memo(function MemoizedLineChart({ data, indicators, showVolume }: {  data: ChartData[];  indicators: string[];  showVolume: boolean;}) {  return (    <ResponsiveContainer height={400} width="100%">      <LineChart data={data}>        <CartesianGrid stroke="#374151" strokeDasharray="3 3" />        <XAxis          dataKey="timestamp"          stroke="#9CA3AF"          tickFormatter={(value) => new Date(value).toLocaleDateString()}        />        <YAxis stroke="#9CA3AF" />        <Tooltip          content={<CustomTooltip />}          contentStyle={{            backgroundColor: '#1F2937',            border: '1px solid #374151',            borderRadius: '8px',            color: '#F9FAFB',          }}        />        <Line          dataKey="close"          dot={false}          name="Price"          stroke="#3B82F6"          strokeWidth={2}          type="monotone"        />        {indicators.includes('sma') && (          <Line            dataKey="sma"            dot={false}            name="SMA"            stroke="#10B981"            strokeWidth={1}            type="monotone"          />        )}        {indicators.includes('ema') && (          <Line            dataKey="ema"            dot={false}            name="EMA"            stroke="#F59E0B"            strokeWidth={1}            type="monotone"          />        )}      </LineChart>    </ResponsiveContainer>  );});const MemoizedAreaChart = memo(function MemoizedAreaChart({ data, indicators }: {  data: ChartData[];  indicators: string[];}) {  return (    <ResponsiveContainer height={400} width="100%">      <AreaChart data={data}>        <CartesianGrid stroke="#374151" strokeDasharray="3 3" />        <XAxis          dataKey="timestamp"          stroke="#9CA3AF"          tickFormatter={(value) => new Date(value).toLocaleDateString()}        />        <YAxis stroke="#9CA3AF" />        <Tooltip          content={<CustomTooltip />}          contentStyle={{            backgroundColor: '#1F2937',            border: '1px solid #374151',            borderRadius: '8px',            color: '#F9FAFB',          }}        />        <Area          dataKey="close"          fill="url(#colorGradient)"          name="Price"          stroke="#3B82F6"          strokeWidth={2}          type="monotone"        />        <defs>          <linearGradient id="colorGradient" x1="0" x2="0" y1="0" y2="1">            <stop offset="5%" stopColor="#3B82F6" stopOpacity={0.3} />            <stop offset="95%" stopColor="#3B82F6" stopOpacity={0.1} />          </linearGradient>        </defs>      </AreaChart>    </ResponsiveContainer>  );});const MemoizedVolumeChart = memo(function MemoizedVolumeChart({ data }: {  data: ChartData[];}) {  return (    <ResponsiveContainer height={200} width="100%">      <BarChart data={data}>        <CartesianGrid stroke="#374151" strokeDasharray="3 3" />        <XAxis          dataKey="timestamp"          stroke="#9CA3AF"          tickFormatter={(value) => new Date(value).toLocaleDateString()}        />        <YAxis stroke="#9CA3AF" />        <Tooltip          content={<CustomTooltip />}          contentStyle={{            backgroundColor: '#1F2937',            border: '1px solid #374151',            borderRadius: '8px',            color: '#F9FAFB',          }}        />        <Bar          dataKey="volume"          fill="#8B5CF6"          name="Volume"        />      </BarChart>    </ResponsiveContainer>  );});// Custom tooltip componentconst CustomTooltip = ({ active, payload, label }: any) => {  if (active && payload && payload.length) {    return (      <div className="bg-slate-800 border border-slate-700 rounded-lg p-3 shadow-lg">        <p className="text-slate-300 text-sm mb-2">          {new Date(label).toLocaleString()}        </p>        {payload.map((entry: any, index: number) => (          <p className="text-sm" key={index} style={{ color: entry.color }}>            {entry.name}: ${entry.value?.toFixed(2) || entry.value}          </p>        ))}      </div>    );  }  return null;};const OptimizedAdvancedCharts = memo(function OptimizedAdvancedCharts({  data,  symbol,  timeframe,  onTimeframeChange,  className,}: AdvancedChartsProps) {  const [chartType, setChartType] = useState<'line' | 'area' | 'candlestick' | 'volume'>('line');  const [indicators, setIndicators] = useState<string[]>(['sma', 'ema']);  const [showVolume, setShowVolume] = useState(true);  const [isLoading, setIsLoading] = useState(false);  const [error, setError] = useState<string | null>(null);  // Performance monitoring  const { renderCount, optimizeRender } = usePerformanceOptimization();  // Memoized data processing  const processedData = useMemo(() => {    try {      if (!data || data.length === 0) return [];      return data.map(item => ({        ...item,        timestamp: item.timestamp,        close: Number(item.close),        open: Number(item.open),        high: Number(item.high),        low: Number(item.low),        volume: Number(item.volume),        sma: item.sma ? Number(item.sma) : undefined,        ema: item.ema ? Number(item.ema) : undefined,        rsi: item.rsi ? Number(item.rsi) : undefined,        macd: item.macd ? Number(item.macd) : undefined,        bb_upper: item.bb_upper ? Number(item.bb_upper) : undefined,        bb_lower: item.bb_lower ? Number(item.bb_lower) : undefined,      }));    } catch (err) {      return [];    }  }, [data]);  // Memoized indicator calculations  const calculateSMA = useCallback((data: ChartData[], period: number, timestamp: number): number => {    const index = data.findIndex(item => item.timestamp === timestamp);    if (index < period - 1) return 0;    const slice = data.slice(index - period + 1, index + 1);    return slice.reduce((sum, item) => sum + item.close, 0) / period;  }, []);  const calculateEMA = useCallback((data: ChartData[], period: number, timestamp: number): number => {    const index = data.findIndex(item => item.timestamp === timestamp);    if (index === 0) return data[0].close;    const multiplier = 2 / (period + 1);    const prevEMA = data[index - 1].ema || data[index - 1].close;    return (data[index].close * multiplier) + (prevEMA * (1 - multiplier));  }, []);  const calculateRSI = useCallback((data: ChartData[], period: number, timestamp: number): number => {    const index = data.findIndex(item => item.timestamp === timestamp);    if (index < period) return 50;    const slice = data.slice(index - period, index + 1);    let gains = 0;    let losses = 0;    for (let i = 1; i < slice.length; i++) {      const change = slice[i].close - slice[i - 1].close;      if (change > 0) gains += change;      else losses += Math.abs(change);    }    const avgGain = gains / period;    const avgLoss = losses / period;    const rs = avgGain / avgLoss;    return 100 - (100 / (1 + rs));  }, []);  // Memoized chart rendering  const renderChart = useCallback(() => {    try {      switch (chartType) {        case 'line':          return (            <MemoizedLineChart              data={processedData}              indicators={indicators}              showVolume={showVolume}            />          );        case 'area':          return (            <MemoizedAreaChart              data={processedData}              indicators={indicators}            />          );        case 'candlestick':          return (            <Suspense fallback={<ChartLoadingFallback />}>              <CandlestickChart data={processedData} />            </Suspense>          );        case 'volume':          return (            <Suspense fallback={<ChartLoadingFallback />}>              <VolumeChart data={processedData} />            </Suspense>          );        default:          return <MemoizedLineChart data={processedData} indicators={indicators} showVolume={showVolume} />;      }    } catch (err) {      return <ChartErrorFallback error={err} />;    }  }, [chartType, processedData, indicators, showVolume]);  // Memoized indicator toggle  const toggleIndicator = useCallback((indicator: string) => {    setIndicators(prev =>      prev.includes(indicator)        ? prev.filter(i => i !== indicator)        : [...prev, indicator],    );  }, []);  // Memoized timeframe change  const handleTimeframeChange = useCallback((newTimeframe: string) => {    optimizeRender(() => {      onTimeframeChange(newTimeframe);    });  }, [onTimeframeChange, optimizeRender]);  // Error boundary for chart rendering  if (error) {    return (      <Card className={`w-full ${className}`}>        <CardContent className="p-6">          <div className="flex items-center justify-center h-64">            <div className="text-center">              <AlertTriangle className="h-12 w-12 text-red-400 mx-auto mb-4" />              <h3 className="text-lg font-semibold text-white mb-2">Chart Error</h3>              <p className="text-slate-400 mb-4">{error}</p>              <Button                className="border-slate-600 text-slate-300"                onClick={() => setError(null)}                variant="outline"              >                Try Again              </Button>            </div>          </div>        </CardContent>      </Card>    );  }  return (    <Card className={`w-full ${className}`}>      <CardHeader>        <div className="flex items-center justify-between">          <div>            <CardTitle className="text-xl font-bold text-white">              {symbol} Advanced Charts            </CardTitle>            <p className="text-slate-400 text-sm">              {timeframe} • {processedData.length} data points            </p>          </div>          <div className="flex items-center space-x-2">            <Badge className="border-slate-600 text-slate-300" variant="outline">              Render #{renderCount}            </Badge>          </div>        </div>      </CardHeader>      <CardContent className="space-y-6">        {/* Chart Type Selection */}        <Tabs onValueChange={(value) => setChartType(value as any)} value={chartType}>          <TabsList className="grid w-full grid-cols-4 bg-slate-800">            <TabsTrigger className="data-[state=active]:bg-slate-700" value="line">              <TrendingUp className="h-4 w-4 mr-2" />              Line            </TabsTrigger>            <TabsTrigger className="data-[state=active]:bg-slate-700" value="area">              <BarChart3 className="h-4 w-4 mr-2" />              Area            </TabsTrigger>            <TabsTrigger className="data-[state=active]:bg-slate-700" value="candlestick">              <Activity className="h-4 w-4 mr-2" />              Candlestick            </TabsTrigger>            <TabsTrigger className="data-[state=active]:bg-slate-700" value="volume">              <Volume2 className="h-4 w-4 mr-2" />              Volume            </TabsTrigger>          </TabsList>        </Tabs>        {/* Chart Container */}        <div className="relative">          {isLoading ? (            <ChartLoadingFallback />          ) : (            renderChart()          )}        </div>        {/* Technical Indicators */}        <div className="space-y-4">          <h3 className="text-lg font-semibold text-white">Technical Indicators</h3>          <div className="flex flex-wrap gap-2">            {['sma', 'ema', 'rsi', 'macd', 'bb'].map((indicator) => (              <Button                className={                  indicators.includes(indicator)                    ? 'bg-blue-600 hover:bg-blue-700'                    : 'border-slate-600 text-slate-300 hover:bg-slate-700'                }                key={indicator}                onClick={() => toggleIndicator(indicator)}                size="sm"                variant={indicators.includes(indicator) ? 'default' : 'outline'}              >                {indicator.toUpperCase()}              </Button>            ))}          </div>        </div>        {/* Timeframe Selection */}        <div className="space-y-4">          <h3 className="text-lg font-semibold text-white">Timeframe</h3>          <div className="flex flex-wrap gap-2">            {['1m', '5m', '15m', '1h', '4h', '1d', '1w'].map((tf) => (              <Button                className={                  timeframe === tf                    ? 'bg-purple-600 hover:bg-purple-700'                    : 'border-slate-600 text-slate-300 hover:bg-slate-700'                }                key={tf}                onClick={() => handleTimeframeChange(tf)}                size="sm"                variant={timeframe === tf ? 'default' : 'outline'}              >                {tf}              </Button>            ))}          </div>        </div>      </CardContent>    </Card>  );});// Loading fallback componentconst ChartLoadingFallback = memo(function ChartLoadingFallback() {  return (    <div className="flex items-center justify-center h-64">      <div className="text-center">        <Loader2 className="h-8 w-8 text-blue-400 animate-spin mx-auto mb-4" />        <p className="text-slate-400">Loading chart...</p>      </div>    </div>  );});// Error fallback componentconst ChartErrorFallback = memo(function ChartErrorFallback({ error }: { error: any }) {  return (    <div className="flex items-center justify-center h-64">      <div className="text-center">        <AlertTriangle className="h-8 w-8 text-red-400 mx-auto mb-4" />        <p className="text-slate-400">Failed to render chart</p>        <p className="text-slate-500 text-sm mt-1">{error?.message}</p>      </div>    </div>  );});export default OptimizedAdvancedCharts;